# Исключения в C++: Подробное объяснение

## Что такое исключения?

**Исключения (exceptions)** — это механизм обработки ошибок в C++, который позволяет программе реагировать на необычные или ошибочные ситуации во время выполнения. Вместо того чтобы проверять код возврата каждой функции, исключения позволяют "выбросить" ошибку в любом месте программы и "поймать" её в подходящем месте.

## Основные концепции

### 1. Генерация исключения (throw)

Исключение генерируется с помощью ключевого слова `throw`:

```cpp
if (value < 0) {
    throw std::invalid_argument("Значение не может быть отрицательным!");
}
```

### 2. Обработка исключения (try-catch)

Блок `try` содержит код, который может выбросить исключение. Блок `catch` обрабатывает исключение:

```cpp
try {
    // Код, который может выбросить исключение
    someFunction();
} catch (const std::exception& e) {
    // Обработка исключения
    std::cout << "Ошибка: " << e.what() << std::endl;
}
```

### 3. Иерархия исключений

В C++ все исключения наследуются от базового класса `std::exception`:

```
std::exception
├── std::logic_error
│   ├── std::invalid_argument
│   ├── std::domain_error
│   └── std::length_error
├── std::runtime_error
│   ├── std::range_error
│   └── std::overflow_error
└── std::bad_alloc (от оператора new)
```

## Типы исключений в стандартной библиотеке

### 1. `std::invalid_argument`
Используется для недопустимых аргументов функции:
```cpp
if (age < 0) {
    throw std::invalid_argument("Возраст не может быть отрицательным");
}
```

### 2. `std::runtime_error`
Используется для ошибок времени выполнения:
```cpp
if (fileNotFound) {
    throw std::runtime_error("Файл не найден");
}
```

### 3. `std::bad_alloc`
Выбрасывается оператором `new` при нехватке памяти:
```cpp
try {
    int* arr = new int[1000000000]; // Может выбросить bad_alloc
} catch (const std::bad_alloc& e) {
    std::cout << "Нехватка памяти!" << std::endl;
}
```

### 4. `std::out_of_range`
Используется для выхода за границы:
```cpp
if (index >= size) {
    throw std::out_of_range("Индекс вне допустимого диапазона");
}
```

### 5. `std::logic_error`
Используется для логических ошибок в программе:
```cpp
if (state == INVALID) {
    throw std::logic_error("Недопустимое состояние объекта");
}
```

## Пользовательские классы исключений

Вы можете создать собственный класс исключения, наследуя его от `std::exception` или его производных:

```cpp
class EmployeeException : public std::runtime_error {
public:
    EmployeeException(const std::string& message) 
        : std::runtime_error(message) {}
};
```

**Преимущества:**
- Можно добавить дополнительную информацию
- Легче различать типы ошибок
- Более понятный код

## Исключения в конструкторах

**Важно:** Если в конструкторе выбрасывается исключение:
- Объект **не считается созданным**
- Деструктор **НЕ вызывается**
- Частично созданные объекты-члены будут уничтожены автоматически

```cpp
Employee::Employee(const std::string& name, int experience, double salary) {
    if (name.empty()) {
        throw EmployeeException("Имя не может быть пустым!");
        // Деструктор НЕ будет вызван, объект не создан
    }
    // ... остальной код конструктора
}
```

## Исключения и оператор new

Оператор `new` может выбросить `std::bad_alloc` при нехватке памяти:

```cpp
try {
    Train* train = new Train(101, "Москва-СПб");
    // Если new выбросил исключение, эта строка не выполнится
} catch (const std::bad_alloc& e) {
    // Память не была выделена, объект не создан
    std::cout << "Нехватка памяти: " << e.what() << std::endl;
}
```

**Альтернатива:** `new (nothrow)` не выбрасывает исключение, а возвращает `nullptr`:
```cpp
Train* train = new (std::nothrow) Train(101, "Москва-СПб");
if (train == nullptr) {
    // Обработка ошибки
}
```

## Перенаправление исключений (Exception Forwarding)

Иногда нужно перехватить исключение, выполнить некоторые действия, а затем передать его дальше:

```cpp
void processData() {
    try {
        // Код, который может выбросить исключение
        throw std::runtime_error("Ошибка");
    } catch (const std::runtime_error& e) {
        std::cout << "Логирование: " << e.what() << std::endl;
        throw; // Перенаправление того же исключения
    }
}
```

**Ключевое слово `throw` без аргументов** перенаправляет текущее исключение дальше по стеку вызовов.

## Функция завершения (Terminate Handler)

Если исключение не было обработано, вызывается функция `std::terminate()`. Вы можете установить свою функцию:

```cpp
void customTerminate() {
    std::cerr << "Необработанное исключение!" << std::endl;
    std::abort(); // Завершение программы
}

int main() {
    std::set_terminate(customTerminate);
    // ...
}
```

## Где используются исключения?

### 1. Валидация входных данных
```cpp
void setAge(int age) {
    if (age < 0 || age > 150) {
        throw std::invalid_argument("Недопустимый возраст");
    }
    this->age = age;
}
```

### 2. Обработка ошибок операций
```cpp
void removeCar(int carNumber) {
    auto it = findCar(carNumber);
    if (it == cars.end()) {
        throw std::runtime_error("Вагон не найден");
    }
    cars.erase(it);
}
```

### 3. Проверка состояния системы
```cpp
void startTrip() {
    if (staff.empty()) {
        throw std::runtime_error("Нет персонала для поездки");
    }
    // ...
}
```

### 4. Обработка ошибок выделения памяти
```cpp
try {
    auto data = std::make_unique<LargeArray>(1000000);
} catch (const std::bad_alloc& e) {
    // Обработка нехватки памяти
}
```

## Преимущества исключений

1. **Разделение кода обработки ошибок** — не нужно проверять код возврата на каждом уровне
2. **Автоматическая очистка** — RAII гарантирует вызов деструкторов
3. **Типобезопасность** — исключения имеют типы, можно обрабатывать разные типы по-разному
4. **Информативность** — можно передать подробное сообщение об ошибке

## Недостатки исключений

1. **Производительность** — обработка исключений может быть медленнее
2. **Сложность отладки** — сложнее отследить поток выполнения
3. **Не все ошибки должны быть исключениями** — для ожидаемых ошибок лучше использовать коды возврата

## Лучшие практики

1. **Используйте исключения для неожиданных ошибок**, а не для обычного потока выполнения
2. **Не выбрасывайте исключения из деструкторов** — это может привести к двойному исключению
3. **Используйте специфичные типы исключений** — это упрощает обработку
4. **Всегда обрабатывайте исключения на верхнем уровне** — чтобы программа не завершалась аварийно
5. **Используйте RAII** — умные указатели автоматически освобождают ресурсы при исключениях

## Примеры из вашего проекта

В вашем проекте реализованы все основные аспекты работы с исключениями:

1. ✅ **Пять типов исключений:**
   - `std::invalid_argument` (недопустимые аргументы)
   - `std::runtime_error` (ошибки времени выполнения)
   - `std::bad_alloc` (нехватка памяти)
   - `EmployeeException` (пользовательское исключение)
   - Различные подтипы `runtime_error`

2. ✅ **Перенаправление исключений:**
   - Функция `demonstrateExceptionForwarding()` показывает, как перенаправить исключение

3. ✅ **Исключение с оператором new:**
   - Метод `Train::createTrainWithException()` демонстрирует `std::bad_alloc`

4. ✅ **Исключение в конструкторе:**
   - Конструктор `Employee` выбрасывает исключение при невалидных данных
   - Показан вызов конструкторов и деструкторов

5. ✅ **Собственная функция завершения:**
   - Функция `customTerminate()` установлена через `std::set_terminate()`

6. ✅ **Пользовательский класс исключения:**
   - Класс `EmployeeException` наследуется от `std::runtime_error`

## Заключение

Исключения — мощный механизм обработки ошибок в C++, который позволяет писать более чистый и безопасный код. Понимание работы исключений критически важно для создания надежных приложений.

